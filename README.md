# 预热问题：
1. 什么叫做六重索引？
2. 关系数据库能实现免索引邻接吗？NoSQL数据库可以吗？
3. 举一个10个节点的BCI知识图谱片段例子，分别用RDF和属性图方式表示，形成文档，docx文档提交。说明RDF和属性图有什么不同。
4. 如何用json格式表示RDF和属性图知识图谱？以上一题中数据为例。
5. 用什么工具编辑json文档？yaml和json是一种文档格式吗？
6. 用python语言如何处理json数据？Julia语言呢？

answer:
```
1.六重索引是针对知识图谱数据和运算的特点提出的一种优化技术，利用知识图谱三元组的特点来构建索引。将三元组中主语、谓语、宾语的各种
排列情况都枚举出来，然后为它们一一构建索引。主语、谓语和宾语的排列情况共计六种。这些索引内容正好对应知识图谱运算中带变量的三元组
模式的各种可能，是一种典型的“空间换时间”策略。
这种方法不仅缓解了三元组表的单表自连接问题，而且加速了图谱的查询效率。但是也增加了更新和维护成本。
方案代表：RDF-3X、Hexastore
六张表：SPO、SOP、PSO、POS、OSP、OPS
SPO表举例：
![image](https://user-images.githubusercontent.com/74064347/150918533-7258188c-1cb6-4d8e-9199-c064a2f5a24d.png)

2.关系数据库不能实现免索引邻接。NoSQL数据库可以实现免索引邻接。图数据库是一种新型的NoSQL数据库，neo4j是一个高性能的NoSQL数据库,
它将结构化数据存储在网络上而不是表中。 neo4j有一个重要的特点，就是用来保证关系查询的速度，即免索引邻接属性，数据库中的每个节点都
会维护与它相邻节点的引用。因此每个节点都相当于与它相邻节点的微索引，这比使用全局索引的代价小很多，这就意味着查询时间和图的整体规模
无关，只与它附近节点的数量成正比。在关系数据库中使用全局索引引接各个节点，这些索引对每个遍历都会增加一个中间层，因此会导致非常大的
计算成本，而免索引邻接为图数据库提供了快速、高效的图遍历能力。
3.
文本：现有研究中，通常利用较多的EEG通道信号获得更多的空域信息来提升性能[8]。然而同时也会引入包含与MI任务无关或冗余信息的通道，从而使用较多的EEG通道并不能保证性能的提升。为了去除与MI任务无关的、冗余的通道，研究者们提出了许多通道选择的方法。Feng等人提出了基于多频带的共空间模式滤波器排序进行通道选择的方法(Common Space Pattern-Rank channel selection for Multi-Frequency band, CSP-R- MF)，结合多频带信号分解滤波和CSP-Rank方法选择通道；Jin等人[12]提出了基于皮尔逊相关系数进行通道选择的方法(Correlation based Channel Selection, CCS)，CCS利用皮尔逊相关系数选择与MI任务相关的通道，之后对这些通道进行正则化共空间模式(Regularized CSP, RCSP)[ 13 ]特征提取；Han等人提出了基于特征压缩和通道排序(FeatureCompression and Channel Ranking, FCCR)的通道选择方法，通过K-Means方法聚类降低特征维数，进而通过结构稀疏最小二乘回归等特征选择方法，对脑电通道进行排序和选择。

RDF图：


属性图：


RDF和属性图的不同表现在：
标签：在RDF图中，标签是在RDFS命名空间即rdfs:label中定义出的标准谓词，用于指向任何资源的显示名称的值。在属性图中，标签用于标识节点的类型。它被称为标签而不是类型，因为它只是一个字符串或一个文本标记，在文本之外没有任何意义，且在图中不能捕捉到关于它的任何信息。
类型：在RDF图中，节点的类型或属性的类型是资源，即通常在图中存在另一个节点带有与其关联的附加信息，以定义其预期的用途和语义。节点使用rdf:type来链接到它的类型。在属性图中，属性中的边具有标识类型的标签。它被称为“类型”或“关系类型”。常被用于查询关系匹配，当图可视化显示时，它也作为边的显示名称。
属性：在RDF图中，边也可称为属性(谓词)，和属性指向的对象可以称为属性值，而所有属性值(文字或URI)都存储为节点。在属性图中，属性只能有文字值。它们的存储和处理的方式与图中的节点不同。
在边上附加信息的差异：在属性图中，不同的两条边可以有相同的类型，但不同的特征。在RDF中，相同类型的边都是相同的，边会被重复使用。

4.
用Json格式表示:
[
    {
        "person":[
            {
                "姓名":"金晶",
                "提出":"基于皮尔逊相关系数进行通道选择"
            },
            {
                "姓名":"冯建奎",
                "提出":"多频带的共空间模式滤波器排序"
            },
            {
                "姓名":"韩久麒",
                "提出":"特征压缩和通道排序"
            }
        ]
    },
    {
        "method":[
            {
                "名称":"基于皮尔逊相关系数进行通道选择",
                "缩写":"CCS",
                "用途":"通道选择"
            },
            {
                "名称":"多频带的共空间模式滤波器排序",
                "缩写":"CSP-R- MF",
                "用途":"通道选择"
            },
            {
                "名称":"特征压缩和通道排序",
                "缩写":"FCCR",
                "用途":"通道选择"
            },
            {
                "名称":"通道选择",
                "筛选":"EEG通道信号",
                "基于":[
                    {
                        "名称":"基于皮尔逊相关系数进行通道选择"
                    },
                    {
                        "名称":"多频带的共空间模式滤波器排序"
                    },
                    {
                        "名称":"特征压缩和通道排序"
                    }
                ]
            }
        ]
    },
    {
        "terminology":[
            {
                "名称":"EEG通道信号",
                "提升性能":"运动想象（MI）任务"
            },
            {
                "名称":"运动想象（MI）任务"
            }
        ]
    }
]
5.json文档实际上是一个特定的数据交换格式，理论上任何文本编辑器都可以编辑json文档(比如vscode，vim).
yaml和json不是一种文档格式，yaml是层次化的，json中是利用数组或者字典并列的.
语法上yaml是json的超集，yaml解析器可以解析json.
二者都是面向对象的(个人理解)

6.python处理json一般使用官方包（import json), dumps/dump, 
loads/load,将python的类型(字典或者数组)转化为json文件/字符串，json文件/字符串转化为python类型（字典或者数组). 
这也是最方便的办法.此外第三方包Demjson可用于编码和解码 JSON 数据，包含了 JSONLint 的格式化及校验功能.
(julia简介）
Julia是一种即时(Just-In-Time，JIT)编译语言,而不是脚本（解释）语言（如Python，R，Ruby等）。
Julia使用LLVM(Low Level Virtual Machine)来进行JIT编译。具体过程是：Julia运行时会生成LLVM中间代码，并将其交给LLVM的JIT编译器，
最终以其生成在CPU上可执行的机器代码。 其实，在LLVM中所构建的编译技术已经为Julia的代码优化建立了一套强大的工作系统： 
既包含简单的操作，如循环展开或循环删除等；也涉及相对复杂的步骤，如SIMD向量化等。可见，是LLVM的存在促成了Julia在真正意义上的诞生。
julia处理json import该包：https://github.com/JuliaIO/JSON.jl 即可
```
